from couchbase.exceptions import  NotSupportedError
from couchbase.options import OptionBlock
from couchbase.management.generic import GenericManager
from typing import *


class UserManager(GenericManager):
    def __init__(self,  # type: UserManager
                 admin):
        """User Manager
        Programmatic access to the user management REST API:
        https://docs.couchbase.com/server/current/rest-api/rbac.html

        Unless otherwise indicated, all objects SHOULD be immutable.
        :param parent_cluster: """
        super(UserManager, self).__init__(admin)

    def get_user(self,  # type: UserManager
                 username,  # type: str
                 domain_name=None,
                 *options  # type: GetUserOptions
                 ):
        # type: (...)->UserAndMetadata
        """
        Gets a user.
        Signature
        UserAndMetadata GetUser(string username, [options])
        Parameters
        Required:
        username: string - ID of the user.
        Optional:
        domainName: string - name of the user domain. Defaults to local.
        Timeout or timeoutMillis (int/duration) - the time allowed for the operation to be terminated. This is controlled by the client.
        Returns
        An instance of UserAndMetadata.
        Throws
        UserNotFoundException
        InvalidArgumentsException
        Any exceptions raised by the underlying platform

        Implementation Notes

        When parsing the "get" and "getAll" responses, take care to distinguish between roles assigned directly to the user (role origin with type="user") and roles inherited from groups (role origin with type="group" and name=<group name>).

        If the server response does not include an "origins" field for a role, then it was generated by a server version prior to 6.5 and the SDK MUST treat the role as if it had a single origin of type="user".
        """
        return RawUserAndMetadata(self._admin_bucket.user_get(domain_name, username))

    def get_all_users(self,  # type: UserManager
                      domain_name,  # type: str
                      *options  # type: GetAllUsersOptions
                      ):
        # type: (...)->Iterable[UserAndMetadata]
        """
        Gets all users.
        Signature
        Iterable<UserAndMetadata> GetAllUsers([options])
        Parameters
        Required:
        Optional:
        domainName: string - name of the user domain. Defaults to local.
        Timeout or timeoutMillis (int/duration) - the time allowed for the operation to be terminated. This is controlled by the client.
        Returns
        An iterable collection of UserAndMetadata.
        Throws
        Any exceptions raised by the underlying platform"""

        return list(map(RawUserAndMetadata, self._admin_bucket.users_get(domain=domain_name)))

    def upsert_user(self,  # type: UserManager
                    user,  # type: IUser
                    *options,  # type: UpsertUserOptions
                    domain=None  # type: str
                    ):
        """UpsertUser
        Creates or updates a user.
        Signature
        void UpsertUser(User user, [options])
        Parameters
        Required:
        user: User - the new version of the user.
        Optional:
        Domain_name: string - name of the user domain (local | external). Defaults to local.
        Timeout or timeoutMillis (int/duration) - the time allowed for the operation to be terminated. This is controlled by the client.
        Returns
        Throws
        InvalidArgumentsException
        Any exceptions raised by the underlying platform

        Implementation Notes

        When building the PUT request to send to the REST endpoint, implementations MUST omit the "password" property if it is not present in the given User domain object (so that the password is only changed if the calling code provided a new password).

        For backwards compatibility with Couchbase Server 6.0 and earlier, the "groups" parameter MUST be omitted if the group list is empty. Couchbase Server 6.5 treats the absent parameter the same as an explicit parameter with no value (removes any existing group associations, which is what we want in this case).
        """
        self._admin_bucket.user_upsert(domain, user, password=user.password, roles=user.roles, name=user.username)

    def drop_user(self,  # type: UserManager
                  user_name,  # type: str
                  domain,  # type: str
                  options  # type: DropUserOptions
                  ):
        """
        DropUser
        Removes a user.
        Signature
        void DropUser(string username, [options])
        Parameters
        Required:
        username: string - ID of the user.
        Optional:
        domain_name: string - name of the user domain. Defaults to local.
        Timeout or timeoutMillis (int/duration) - the time allowed for the operation to be terminated. This is controlled by the client.
        Returns
        Throws
        UserNotFoundException
        InvalidArgumentsException
        Any exceptions raised by the underlying platform
        """
        self._admin_bucket.user_remove(domain, user_name)

    def get_roles(self,  # type: UserManager
                  options  # type: GetRolesOptions
                  ):
        # type: (...)->Iterable[RoleAndDescription]
        """
        Get Roles
        Returns the roles supported by the server.
        Signature
        Iterable<RoleAndDescription> GetRoles([options])
        Parameters
        Optional:
        Timeout or timeoutMillis (int/duration) - the time allowed for the operation to be terminated. This is controlled by the client.
        Returns
        An iterable collection of RoleAndDescription.
        Throws
        Any exceptions raised by the underlying platform
        """
        raise NotSupportedError("To be implemented")

    def get_group(self,  # type: UserManager
                  group_name,  # type: str
                  options  # type: GetGroupOptions
                  ):
        # type: (...)->Group
        """
        GetGroup
        Gets a group.

        REST Endpoint: GET /settings/rbac/groups/<name>
        Signature
        Group GetGroup(string groupName, [options])
        Parameters
        Required:
        groupName: string - name of the group to get.
        Optional:
        Timeout or timeoutMillis (int/duration) - the time allowed for the operation to be terminated. This is controlled by the client.
        Returns
        An instance of Group.
        Throws
        GroupNotFoundException
        InvalidArgumentsException
        Any exceptions raised by the underlying platform
        """
        raise NotSupportedError("To be implemented")

    def get_all_groups(self,  # type: UserManager
                       options  # type: GetAllGroupsOptions
                       ):
        # type: (...)->Iterable[Group]
        """
        GetAllGroups
        Gets all groups.

        REST Endpoint: GET /settings/rbac/groups
        Signature
        Iterable<Group> GetAllGroups([options])
        Parameters
        Required:
        Optional:
        Timeout or timeoutMillis (int/duration) - the time allowed for the operation to be terminated. This is controlled by the client.
        Returns
        An iterable collection of Group.
        Throws
        Any exceptions raised by the underlying platform"""
        raise NotSupportedError("To be implemented")


    def upsert_group(self,  # type: UserManager
                     group,  # type: Group
                     options  # type: UpsertGroupOptions
                     ):
        """
        UpsertGroup
        Creates or updates a group.

        REST Endpoint: PUT /settings/rbac/groups/<name>
        This endpoint accepts application/x-www-form-urlencoded and requires the data be sent as form data. The name/id should not be included in the form data. Roles should be a comma separated list of strings. If, only if, the role contains a bucket name then the rolename should be suffixed with[<bucket_name>] e.g. bucket_full_access[default],security_admin.
        Signature
        void UpsertGroup(Group group, [options])
        Parameters
        Required:
        group: Group - the new version of the group.
        Optional:
        Timeout or timeoutMillis (int/duration) - the time allowed for the operation to be terminated. This is controlled by the client.
        Returns
        Throws
        InvalidArgumentsException
        Any exceptions raised by the underlying platform"""
        raise NotSupportedError("To be implemented")

    def drop_group(self,  # type: UserManager
                   group_name,  # type: str
                   options  # type: DropGroupOptions
                   ):
        """
        DropGroup
        Removes a group.

        REST Endpoint: DELETE /settings/rbac/groups/<name>
        Signature
        void DropGroup(string groupName, [options])
        Parameters
        Required:
        groupName: string - name of the group.
        Optional:
        Timeout or timeoutMillis (int/duration) - the time allowed for the operation to be terminated. This is controlled by the client.
        Returns
        Throws
        GroupNotFoundException
        InvalidArgumentsException
        Any exceptions raised by the underlying platform
        Collections Manager
        Note,  # type: due to https://issues.couchbase.com/browse/MB-35386 CollectionExists
        ScopeExists, and GetScope must support both forms of the manifest until SDK beta. That is, going forward:

        {"uid":"0","scopes":[{"name":"_default","uid":"0","collections":[{"name":"_default","uid":"0"}]}]}

        And for the sake of support for the server beta which did not have the fix in place:
        {"uid":0,"scopes":{"_default":{"uid":0,"collections":{"_default":{"uid":0}}}}}
        It is recommended to try to parse the first form and fallback to the second so that it can be easily removed later.
        """
        raise NotSupportedError("To be implemented")


class Role(object):
    def __init__(self):
        """A role identifies a specific permission. CAVEAT,  # type: The properties of a role are likely to change with the introduction of collection-level permissions. Until then
        here's what the accessor methods look like:
        """

    @property
    def name(self):
        return

    @property
    def bucket(self):
        return


class RawRole(Role):
    def __init__(self, raw_data):
        self._raw_data=raw_data


    @property
    def name(self):
        return self._raw_data.get('name')

    @property
    def bucket(self):
        return self._raw_data.get('bucket')


class RoleAndDescription(object):
    def __init__(self):
        """ Associates a role with its name and description. This is additional information only present in the "list available roles" response."""
        pass

    @property
    def role(self):
        # type: (...)->Role
        return None

    @property
    def display_name(self):
        # type: (...)->str
        return None

    @property
    def description(self):
        # type: (...)->str
        pass


class Origin(object):
    def __init__(self):
        """Indicates why the user has a specific role.
        If the type is "user" it means the role is assigned directly to the user. If the type is "group" it means the role is inherited from the group identified by the "name" field."""

    @property
    def type(self):
        # type: (...)->str
        pass

    @property
    def name(self):
        # type: (...)->str
        return None


class RoleAndOrigins(object):
    def __init__(self):
        """Associates a role with its origins.
        This is how roles are returned by the "get user" and "get all users" responses."""

    @property
    def role(self):
        # type: (...)->Role
        pass

    @property
    def origins(self):
        # type: (...)->List[Origin]
        pass


class IUser(object):
    def __init__(self):
        """Mutable. Models the user properties that may be updated via this API.
        All properties of the User class MUST have associated setters except for "username" which is fixed when the object is created"""

    @property
    def username(self):
        # type: (...)->str
        pass

    @property
    def display_name(self):
        # type: (...)->str
        pass

    @property
    def groups(self):
        # type: (...)->Set[str]
        pass
        """names of the groups"""

    @property
    def roles(self):
        # type: (...)->Set[Role]
        """only roles assigned directly to the user (not inherited from groups)"""
        pass

    @property
    def password(self):
        # type: (...)->None
        pass
        """ From the user's perspective the password property is "write-only".
        The accessor SHOULD be hidden from the user and be visible only to the manager implementation."""

    @password.setter
    def password(self, value):
        pass


class User(IUser):
    def __init__(self, **raw_data):
        self._raw_data=raw_data

    @property
    def username(self):
        # type: (...)->str
        return self._raw_data.get('username')

    @property
    def display_name(self):
        # type: (...)->str
        return self._raw_data.get('username')

    @property
    def groups(self):
        # type: (...)->Set[str]
        """names of the groups"""
        return set(self._raw_data.get('groups'))

    @property
    def roles(self):
        # type: (...)->Set[Role]
        """only roles assigned directly to the user (not inherited from groups)"""
        return set(map(RawRole, self._raw_data.get('groups')))

    @property
    def password(self):
        # type: (...)->None
        """ From the user's perspective the password property is "write-only".
        The accessor SHOULD be hidden from the user and be visible only to the manager implementation."""
        return self._raw_data.get('password')

    @password.setter
    def password(self, value):
        self._raw_data['password']=value


class UserAndMetadata(object):
    def __init__(self):
        """Models the "get user" / "get all users" response.
        Associates the mutable properties of a user with derived properties such as the effective roles inherited from groups."""

    @property
    def domain(self):
        # type: (...)->AuthDomain
        """ AuthDomain is an enumeration with values "local" and "external".
        It MAY alternatively be represented as String."""

    @property
    def user(self):
        # type: (...)->IUser
        """- returns a new mutable User object each time this method is called.
        Modifying the fields of the returned User MUST have no effect on the UserAndMetadata object it came from."""

    @property
    def effective_roles(self):
        # type: (...)->Set[Role]
        """all roles, regardless of origin."""

    @property
    def effective_roles_and_origins(self):
        # type: (...)->List[RoleAndOrigins]
        """same as effectiveRoles, but with origin information included."""
        pass

    @property
    def password_changed(self):
        # type: (...)->Optional[float]
        pass

    @property
    def external_groups(self):
        # type: (...)->Set[str]
        pass



class RawUserAndMetadata(UserAndMetadata):
    def __init__(self, raw_data):
        self._raw_data=raw_data


    @property
    def domain(self):
        # type: (...)->str
        """ AuthDomain is an enumeration with values "local" and "external".
        It MAY alternatively be represented as String."""
        return self._raw_data.get('domain')

    @property
    def user(self):
        # type: (...)->IUser
        """- returns a new mutable User object each time this method is called.
        Modifying the fields of the returned User MUST have no effect on the UserAndMetadata object it came from."""
        return User(**self._raw_data.get('user'))

    @property
    def effective_roles(self):
        # type: (...)->Set[Role]
        """all roles, regardless of origin."""

    @property
    def effective_roles_and_origins(self):
        # type: (...)->List[RoleAndOrigins]
        """same as effectiveRoles, but with origin information included."""
        pass

    @property
    def password_changed(self):
        # type: (...)->Optional[float]
        pass

    @property
    def external_groups(self):
        # type: (...)->Set[str]
        pass
class Group(object):
    def __init__(self):
        """Mutable. Defines a set of roles that may be inherited by users.
        All properties of the Group class MUST have associated setters except for "name" which is fixed when the object is created."""

    @property
    def name(self):
        # type: (...)->str
        pass

    @property
    def description(self):
        # type: (...)->str
        pass

    def roles(self):
        # type: (...)->Set[Role]
        pass
        """- Role as defined in the User Manager section"""

    @property
    def ldap_group_reference(self):
        # type: (...)->str
        pass


class GetUserOptions(OptionBlock):
    pass


class UpsertUserOptions(OptionBlock):
    pass


class GetRolesOptions(OptionBlock):
    pass


class GetGroupOptions(OptionBlock):
    pass


class GetAllGroupsOptions(OptionBlock):
    pass


class DropGroupOptions(OptionBlock):
    pass


class DropUserOptions(OptionBlock):
    pass


class GetAllUsersOptions(OptionBlock):
    pass


class UpsertGroupOptions(OptionBlock):
    pass
